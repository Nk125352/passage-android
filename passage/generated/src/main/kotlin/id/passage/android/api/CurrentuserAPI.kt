/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package id.passage.android.api

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import id.passage.android.model.ApiCurrentUserDevice
import id.passage.android.model.ApiCurrentUserDevices
import id.passage.android.model.ApiMagicLinkResponse
import id.passage.android.model.ApiaddDeviceFinishRequest
import id.passage.android.model.ApiaddDeviceStartResponse
import id.passage.android.model.ApiupdateDeviceRequest
import id.passage.android.model.ApiupdateMetadataRequest
import id.passage.android.model.HttpErrorsHTTPError
import id.passage.android.model.ModelsCurrentUser
import id.passage.android.model.UserUpdateUserEmailRequest
import id.passage.android.model.UserUpdateUserPhoneRequest

import com.squareup.moshi.Json

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import id.passage.client.infrastructure.ApiClient
import id.passage.client.infrastructure.ApiResponse
import id.passage.client.infrastructure.ClientException
import id.passage.client.infrastructure.ClientError
import id.passage.client.infrastructure.ServerException
import id.passage.client.infrastructure.ServerError
import id.passage.client.infrastructure.MultiValueMap
import id.passage.client.infrastructure.PartConfig
import id.passage.client.infrastructure.RequestConfig
import id.passage.client.infrastructure.RequestMethod
import id.passage.client.infrastructure.ResponseType
import id.passage.client.infrastructure.Success
import id.passage.client.infrastructure.toMultiValue

class CurrentuserAPI(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://auth.passage.id/v1")
        }
    }

    /**
     * Revoke Device
     * Revoke a device by ID for the current user. User must be authenticated via a bearer token.
     * @param appId App ID
     * @param deviceId Device ID
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun deleteCurrentuserDevice(appId: kotlin.String, deviceId: kotlin.String) : Unit = withContext(Dispatchers.IO) {
        val localVarResponse = deleteCurrentuserDeviceWithHttpInfo(appId = appId, deviceId = deviceId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Revoke Device
     * Revoke a device by ID for the current user. User must be authenticated via a bearer token.
     * @param appId App ID
     * @param deviceId Device ID
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun deleteCurrentuserDeviceWithHttpInfo(appId: kotlin.String, deviceId: kotlin.String) : ApiResponse<Unit?> = withContext(Dispatchers.IO) {
        val localVariableConfig = deleteCurrentuserDeviceRequestConfig(appId = appId, deviceId = deviceId)

        return@withContext request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteCurrentuserDevice
     *
     * @param appId App ID
     * @param deviceId Device ID
     * @return RequestConfig
     */
    fun deleteCurrentuserDeviceRequestConfig(appId: kotlin.String, deviceId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/apps/{app_id}/currentuser/devices/{device_id}/".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())).replace("{"+"device_id"+"}", encodeURIComponent(deviceId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get Current User
     * Get information about a user that is currently authenticated via bearer token.
     * @param appId App ID
     * @return ModelsCurrentUser
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getCurrentuser(appId: kotlin.String) : ModelsCurrentUser = withContext(Dispatchers.IO) {
        val localVarResponse = getCurrentuserWithHttpInfo(appId = appId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ModelsCurrentUser
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Current User
     * Get information about a user that is currently authenticated via bearer token.
     * @param appId App ID
     * @return ApiResponse<ModelsCurrentUser?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun getCurrentuserWithHttpInfo(appId: kotlin.String) : ApiResponse<ModelsCurrentUser?> = withContext(Dispatchers.IO) {
        val localVariableConfig = getCurrentuserRequestConfig(appId = appId)

        return@withContext request<Unit, ModelsCurrentUser>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getCurrentuser
     *
     * @param appId App ID
     * @return RequestConfig
     */
    fun getCurrentuserRequestConfig(appId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/apps/{app_id}/currentuser/".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * List Devices
     * List all WebAuthn devices for the authenticated user. User must be authenticated via bearer token.
     * @param appId App ID
     * @return ApiCurrentUserDevices
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getCurrentuserDevices(appId: kotlin.String) : ApiCurrentUserDevices = withContext(Dispatchers.IO) {
        val localVarResponse = getCurrentuserDevicesWithHttpInfo(appId = appId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ApiCurrentUserDevices
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List Devices
     * List all WebAuthn devices for the authenticated user. User must be authenticated via bearer token.
     * @param appId App ID
     * @return ApiResponse<ApiCurrentUserDevices?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun getCurrentuserDevicesWithHttpInfo(appId: kotlin.String) : ApiResponse<ApiCurrentUserDevices?> = withContext(Dispatchers.IO) {
        val localVariableConfig = getCurrentuserDevicesRequestConfig(appId = appId)

        return@withContext request<Unit, ApiCurrentUserDevices>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getCurrentuserDevices
     *
     * @param appId App ID
     * @return RequestConfig
     */
    fun getCurrentuserDevicesRequestConfig(appId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/apps/{app_id}/currentuser/devices/".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get user&#39;s metadata
     * Get the user-metadata for the current user.
     * @param appId App ID
     * @return ModelsCurrentUser
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getCurrentuserMetadata(appId: kotlin.String) : ModelsCurrentUser = withContext(Dispatchers.IO) {
        val localVarResponse = getCurrentuserMetadataWithHttpInfo(appId = appId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ModelsCurrentUser
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get user&#39;s metadata
     * Get the user-metadata for the current user.
     * @param appId App ID
     * @return ApiResponse<ModelsCurrentUser?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun getCurrentuserMetadataWithHttpInfo(appId: kotlin.String) : ApiResponse<ModelsCurrentUser?> = withContext(Dispatchers.IO) {
        val localVariableConfig = getCurrentuserMetadataRequestConfig(appId = appId)

        return@withContext request<Unit, ModelsCurrentUser>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getCurrentuserMetadata
     *
     * @param appId App ID
     * @return RequestConfig
     */
    fun getCurrentuserMetadataRequestConfig(appId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/apps/{app_id}/currentuser/user-metadata/".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Finish WebAuthn Add Device
     * Complete a WebAuthn add device operation for the current user. This endpoint accepts and verifies the response from &#x60;navigator.credential.create()&#x60; and returns the created device for the user. User must be authenticated via a bearer token.
     * @param appId App ID
     * @param user WebAuthn Response Data
     * @return ApiCurrentUserDevice
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun postCurrentuserAddDeviceFinish(appId: kotlin.String, user: ApiaddDeviceFinishRequest) : ApiCurrentUserDevice = withContext(Dispatchers.IO) {
        val localVarResponse = postCurrentuserAddDeviceFinishWithHttpInfo(appId = appId, user = user)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ApiCurrentUserDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Finish WebAuthn Add Device
     * Complete a WebAuthn add device operation for the current user. This endpoint accepts and verifies the response from &#x60;navigator.credential.create()&#x60; and returns the created device for the user. User must be authenticated via a bearer token.
     * @param appId App ID
     * @param user WebAuthn Response Data
     * @return ApiResponse<ApiCurrentUserDevice?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun postCurrentuserAddDeviceFinishWithHttpInfo(appId: kotlin.String, user: ApiaddDeviceFinishRequest) : ApiResponse<ApiCurrentUserDevice?> = withContext(Dispatchers.IO) {
        val localVariableConfig = postCurrentuserAddDeviceFinishRequestConfig(appId = appId, user = user)

        return@withContext request<ApiaddDeviceFinishRequest, ApiCurrentUserDevice>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postCurrentuserAddDeviceFinish
     *
     * @param appId App ID
     * @param user WebAuthn Response Data
     * @return RequestConfig
     */
    fun postCurrentuserAddDeviceFinishRequestConfig(appId: kotlin.String, user: ApiaddDeviceFinishRequest) : RequestConfig<ApiaddDeviceFinishRequest> {
        val localVariableBody = user
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/apps/{app_id}/currentuser/devices/finish".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Start WebAuthn Add Device
     * Initiate a WebAuthn add device operation for the current user. This endpoint creates a WebAuthn credential creation challenge that is used to perform the registration ceremony from the browser. User must be authenticated via a bearer token.
     * @param appId App ID
     * @return ApiaddDeviceStartResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun postCurrentuserAddDeviceStart(appId: kotlin.String) : ApiaddDeviceStartResponse = withContext(Dispatchers.IO) {
        val localVarResponse = postCurrentuserAddDeviceStartWithHttpInfo(appId = appId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ApiaddDeviceStartResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Start WebAuthn Add Device
     * Initiate a WebAuthn add device operation for the current user. This endpoint creates a WebAuthn credential creation challenge that is used to perform the registration ceremony from the browser. User must be authenticated via a bearer token.
     * @param appId App ID
     * @return ApiResponse<ApiaddDeviceStartResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun postCurrentuserAddDeviceStartWithHttpInfo(appId: kotlin.String) : ApiResponse<ApiaddDeviceStartResponse?> = withContext(Dispatchers.IO) {
        val localVariableConfig = postCurrentuserAddDeviceStartRequestConfig(appId = appId)

        return@withContext request<Unit, ApiaddDeviceStartResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postCurrentuserAddDeviceStart
     *
     * @param appId App ID
     * @return RequestConfig
     */
    fun postCurrentuserAddDeviceStartRequestConfig(appId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/apps/{app_id}/currentuser/devices/start/".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Update Device
     * Update a device by ID for the current user. Currently the only field that can be updated is the friendly name. User must be authenticated via a bearer token.
     * @param appId App ID
     * @param deviceId Device ID
     * @param friendlyName Friendly Name
     * @return ApiCurrentUserDevice
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun updateCurrentuserDevice(appId: kotlin.String, deviceId: kotlin.String, friendlyName: ApiupdateDeviceRequest) : ApiCurrentUserDevice = withContext(Dispatchers.IO) {
        val localVarResponse = updateCurrentuserDeviceWithHttpInfo(appId = appId, deviceId = deviceId, friendlyName = friendlyName)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ApiCurrentUserDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update Device
     * Update a device by ID for the current user. Currently the only field that can be updated is the friendly name. User must be authenticated via a bearer token.
     * @param appId App ID
     * @param deviceId Device ID
     * @param friendlyName Friendly Name
     * @return ApiResponse<ApiCurrentUserDevice?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun updateCurrentuserDeviceWithHttpInfo(appId: kotlin.String, deviceId: kotlin.String, friendlyName: ApiupdateDeviceRequest) : ApiResponse<ApiCurrentUserDevice?> = withContext(Dispatchers.IO) {
        val localVariableConfig = updateCurrentuserDeviceRequestConfig(appId = appId, deviceId = deviceId, friendlyName = friendlyName)

        return@withContext request<ApiupdateDeviceRequest, ApiCurrentUserDevice>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateCurrentuserDevice
     *
     * @param appId App ID
     * @param deviceId Device ID
     * @param friendlyName Friendly Name
     * @return RequestConfig
     */
    fun updateCurrentuserDeviceRequestConfig(appId: kotlin.String, deviceId: kotlin.String, friendlyName: ApiupdateDeviceRequest) : RequestConfig<ApiupdateDeviceRequest> {
        val localVariableBody = friendlyName
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/apps/{app_id}/currentuser/devices/{device_id}/".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())).replace("{"+"device_id"+"}", encodeURIComponent(deviceId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Update user&#39;s metadata
     * Update the metadata for the current user. Only valid metadata fields are accepted. Invalid metadata fields that are present will abort the update. User must be authenticated via a bearer token.
     * @param appId App ID
     * @param userMetadata User Metadata
     * @return ModelsCurrentUser
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun updateCurrentuserMetadata(appId: kotlin.String, userMetadata: ApiupdateMetadataRequest) : ModelsCurrentUser = withContext(Dispatchers.IO) {
        val localVarResponse = updateCurrentuserMetadataWithHttpInfo(appId = appId, userMetadata = userMetadata)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ModelsCurrentUser
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update user&#39;s metadata
     * Update the metadata for the current user. Only valid metadata fields are accepted. Invalid metadata fields that are present will abort the update. User must be authenticated via a bearer token.
     * @param appId App ID
     * @param userMetadata User Metadata
     * @return ApiResponse<ModelsCurrentUser?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun updateCurrentuserMetadataWithHttpInfo(appId: kotlin.String, userMetadata: ApiupdateMetadataRequest) : ApiResponse<ModelsCurrentUser?> = withContext(Dispatchers.IO) {
        val localVariableConfig = updateCurrentuserMetadataRequestConfig(appId = appId, userMetadata = userMetadata)

        return@withContext request<ApiupdateMetadataRequest, ModelsCurrentUser>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateCurrentuserMetadata
     *
     * @param appId App ID
     * @param userMetadata User Metadata
     * @return RequestConfig
     */
    fun updateCurrentuserMetadataRequestConfig(appId: kotlin.String, userMetadata: ApiupdateMetadataRequest) : RequestConfig<ApiupdateMetadataRequest> {
        val localVariableBody = userMetadata
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/apps/{app_id}/currentuser/user-metadata/".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Change Email
     * Initiate an email change for the authenticated user. An email change requires verification, so an email will be sent to the user which they must verify before the email change takes effect.
     * @param appId App ID
     * @param user email
     * @return ApiMagicLinkResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun updateEmailCurrentuser(appId: kotlin.String, user: UserUpdateUserEmailRequest) : ApiMagicLinkResponse = withContext(Dispatchers.IO) {
        val localVarResponse = updateEmailCurrentuserWithHttpInfo(appId = appId, user = user)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ApiMagicLinkResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Change Email
     * Initiate an email change for the authenticated user. An email change requires verification, so an email will be sent to the user which they must verify before the email change takes effect.
     * @param appId App ID
     * @param user email
     * @return ApiResponse<ApiMagicLinkResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun updateEmailCurrentuserWithHttpInfo(appId: kotlin.String, user: UserUpdateUserEmailRequest) : ApiResponse<ApiMagicLinkResponse?> = withContext(Dispatchers.IO) {
        val localVariableConfig = updateEmailCurrentuserRequestConfig(appId = appId, user = user)

        return@withContext request<UserUpdateUserEmailRequest, ApiMagicLinkResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateEmailCurrentuser
     *
     * @param appId App ID
     * @param user email
     * @return RequestConfig
     */
    fun updateEmailCurrentuserRequestConfig(appId: kotlin.String, user: UserUpdateUserEmailRequest) : RequestConfig<UserUpdateUserEmailRequest> {
        val localVariableBody = user
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/apps/{app_id}/currentuser/email/".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Change Phone
     * Initiate a phone number change for the authenticated user. An phone number change requires verification, so an SMS with a link will be sent to the user which they must verify before the phone number change takes effect.
     * @param appId App ID
     * @param user phone
     * @return ApiMagicLinkResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun updatePhoneCurrentuser(appId: kotlin.String, user: UserUpdateUserPhoneRequest) : ApiMagicLinkResponse = withContext(Dispatchers.IO) {
        val localVarResponse = updatePhoneCurrentuserWithHttpInfo(appId = appId, user = user)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ApiMagicLinkResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Change Phone
     * Initiate a phone number change for the authenticated user. An phone number change requires verification, so an SMS with a link will be sent to the user which they must verify before the phone number change takes effect.
     * @param appId App ID
     * @param user phone
     * @return ApiResponse<ApiMagicLinkResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun updatePhoneCurrentuserWithHttpInfo(appId: kotlin.String, user: UserUpdateUserPhoneRequest) : ApiResponse<ApiMagicLinkResponse?> = withContext(Dispatchers.IO) {
        val localVariableConfig = updatePhoneCurrentuserRequestConfig(appId = appId, user = user)

        return@withContext request<UserUpdateUserPhoneRequest, ApiMagicLinkResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updatePhoneCurrentuser
     *
     * @param appId App ID
     * @param user phone
     * @return RequestConfig
     */
    fun updatePhoneCurrentuserRequestConfig(appId: kotlin.String, user: UserUpdateUserPhoneRequest) : RequestConfig<UserUpdateUserPhoneRequest> {
        val localVariableBody = user
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/apps/{app_id}/currentuser/phone/".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
