/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package id.passage.android.api

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import id.passage.android.model.ApiAuthResponse
import id.passage.android.model.ApiactivateMagicLinkRequest
import id.passage.android.model.ApigetMagicLinkStatusRequest
import id.passage.android.model.ApimagicLinkLoginWebAuthnFinishRequest
import id.passage.android.model.ApimagicLinkLoginWebAuthnStartResponse
import id.passage.android.model.ApimagicLinkNewDeviceWebAuthnFinishRequest
import id.passage.android.model.ApimagicLinkNewDeviceWebAuthnStartResponse
import id.passage.android.model.HttpErrorsHTTPError

import com.squareup.moshi.Json

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import id.passage.client.infrastructure.ApiClient
import id.passage.client.infrastructure.ApiResponse
import id.passage.client.infrastructure.ClientException
import id.passage.client.infrastructure.ClientError
import id.passage.client.infrastructure.ServerException
import id.passage.client.infrastructure.ServerError
import id.passage.client.infrastructure.MultiValueMap
import id.passage.client.infrastructure.PartConfig
import id.passage.client.infrastructure.RequestConfig
import id.passage.client.infrastructure.RequestMethod
import id.passage.client.infrastructure.ResponseType
import id.passage.client.infrastructure.Success
import id.passage.client.infrastructure.toMultiValue

class MagicLinkAPI(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://auth.passage.id/v1")
        }
    }

    /**
     * Authenticate Magic Link
     * Authenticate a magic link for a user. This endpoint checks that the magic link is valid, then returns an authentication token for the user.
     * @param appId App ID
     * @param user User Data
     * @return ApiAuthResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun activateMagicLink(appId: kotlin.String, user: ApiactivateMagicLinkRequest) : ApiAuthResponse = withContext(Dispatchers.IO) {
        val localVarResponse = activateMagicLinkWithHttpInfo(appId = appId, user = user)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ApiAuthResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Authenticate Magic Link
     * Authenticate a magic link for a user. This endpoint checks that the magic link is valid, then returns an authentication token for the user.
     * @param appId App ID
     * @param user User Data
     * @return ApiResponse<ApiAuthResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun activateMagicLinkWithHttpInfo(appId: kotlin.String, user: ApiactivateMagicLinkRequest) : ApiResponse<ApiAuthResponse?> = withContext(Dispatchers.IO) {
        val localVariableConfig = activateMagicLinkRequestConfig(appId = appId, user = user)

        return@withContext request<ApiactivateMagicLinkRequest, ApiAuthResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation activateMagicLink
     *
     * @param appId App ID
     * @param user User Data
     * @return RequestConfig
     */
    fun activateMagicLinkRequestConfig(appId: kotlin.String, user: ApiactivateMagicLinkRequest) : RequestConfig<ApiactivateMagicLinkRequest> {
        val localVariableBody = user
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/apps/{app_id}/magic-link/activate/".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Finish a WebAuthn registration, initiated by a magic link.
     * 
     * @param appId App ID
     * @param user User Data
     * @return ApiAuthResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun activateMagicLinkWebauthnLoginFinish(appId: kotlin.String, user: ApimagicLinkLoginWebAuthnFinishRequest) : ApiAuthResponse = withContext(Dispatchers.IO) {
        val localVarResponse = activateMagicLinkWebauthnLoginFinishWithHttpInfo(appId = appId, user = user)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ApiAuthResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Finish a WebAuthn registration, initiated by a magic link.
     * 
     * @param appId App ID
     * @param user User Data
     * @return ApiResponse<ApiAuthResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun activateMagicLinkWebauthnLoginFinishWithHttpInfo(appId: kotlin.String, user: ApimagicLinkLoginWebAuthnFinishRequest) : ApiResponse<ApiAuthResponse?> = withContext(Dispatchers.IO) {
        val localVariableConfig = activateMagicLinkWebauthnLoginFinishRequestConfig(appId = appId, user = user)

        return@withContext request<ApimagicLinkLoginWebAuthnFinishRequest, ApiAuthResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation activateMagicLinkWebauthnLoginFinish
     *
     * @param appId App ID
     * @param user User Data
     * @return RequestConfig
     */
    fun activateMagicLinkWebauthnLoginFinishRequestConfig(appId: kotlin.String, user: ApimagicLinkLoginWebAuthnFinishRequest) : RequestConfig<ApimagicLinkLoginWebAuthnFinishRequest> {
        val localVariableBody = user
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/apps/{app_id}/magic-link/webauthn/login/finish/".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Authenticate the user via magic link, then initiate a WebAuthn login.
     * 
     * @param appId App ID
     * @param user User Data
     * @return ApimagicLinkLoginWebAuthnStartResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun activateMagicLinkWebauthnLoginStart(appId: kotlin.String, user: ApiactivateMagicLinkRequest) : ApimagicLinkLoginWebAuthnStartResponse = withContext(Dispatchers.IO) {
        val localVarResponse = activateMagicLinkWebauthnLoginStartWithHttpInfo(appId = appId, user = user)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ApimagicLinkLoginWebAuthnStartResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Authenticate the user via magic link, then initiate a WebAuthn login.
     * 
     * @param appId App ID
     * @param user User Data
     * @return ApiResponse<ApimagicLinkLoginWebAuthnStartResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun activateMagicLinkWebauthnLoginStartWithHttpInfo(appId: kotlin.String, user: ApiactivateMagicLinkRequest) : ApiResponse<ApimagicLinkLoginWebAuthnStartResponse?> = withContext(Dispatchers.IO) {
        val localVariableConfig = activateMagicLinkWebauthnLoginStartRequestConfig(appId = appId, user = user)

        return@withContext request<ApiactivateMagicLinkRequest, ApimagicLinkLoginWebAuthnStartResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation activateMagicLinkWebauthnLoginStart
     *
     * @param appId App ID
     * @param user User Data
     * @return RequestConfig
     */
    fun activateMagicLinkWebauthnLoginStartRequestConfig(appId: kotlin.String, user: ApiactivateMagicLinkRequest) : RequestConfig<ApiactivateMagicLinkRequest> {
        val localVariableBody = user
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/apps/{app_id}/magic-link/webauthn/login/start/".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Finish WebAuthn registration that was initiated from a magic link.
     * 
     * @param appId App ID
     * @param user User Data
     * @return ApiAuthResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun activateMagicLinkWebauthnNewDeviceFinish(appId: kotlin.String, user: ApimagicLinkNewDeviceWebAuthnFinishRequest) : ApiAuthResponse = withContext(Dispatchers.IO) {
        val localVarResponse = activateMagicLinkWebauthnNewDeviceFinishWithHttpInfo(appId = appId, user = user)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ApiAuthResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Finish WebAuthn registration that was initiated from a magic link.
     * 
     * @param appId App ID
     * @param user User Data
     * @return ApiResponse<ApiAuthResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun activateMagicLinkWebauthnNewDeviceFinishWithHttpInfo(appId: kotlin.String, user: ApimagicLinkNewDeviceWebAuthnFinishRequest) : ApiResponse<ApiAuthResponse?> = withContext(Dispatchers.IO) {
        val localVariableConfig = activateMagicLinkWebauthnNewDeviceFinishRequestConfig(appId = appId, user = user)

        return@withContext request<ApimagicLinkNewDeviceWebAuthnFinishRequest, ApiAuthResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation activateMagicLinkWebauthnNewDeviceFinish
     *
     * @param appId App ID
     * @param user User Data
     * @return RequestConfig
     */
    fun activateMagicLinkWebauthnNewDeviceFinishRequestConfig(appId: kotlin.String, user: ApimagicLinkNewDeviceWebAuthnFinishRequest) : RequestConfig<ApimagicLinkNewDeviceWebAuthnFinishRequest> {
        val localVariableBody = user
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/apps/{app_id}/magic-link/webauthn/new/finish/".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Authenticate the user via magic link, then initiate a WebAuthn registration.
     * 
     * @param appId App ID
     * @param user User Data
     * @return ApimagicLinkNewDeviceWebAuthnStartResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun activateMagicLinkWebauthnNewDeviceStart(appId: kotlin.String, user: ApiactivateMagicLinkRequest) : ApimagicLinkNewDeviceWebAuthnStartResponse = withContext(Dispatchers.IO) {
        val localVarResponse = activateMagicLinkWebauthnNewDeviceStartWithHttpInfo(appId = appId, user = user)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ApimagicLinkNewDeviceWebAuthnStartResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Authenticate the user via magic link, then initiate a WebAuthn registration.
     * 
     * @param appId App ID
     * @param user User Data
     * @return ApiResponse<ApimagicLinkNewDeviceWebAuthnStartResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun activateMagicLinkWebauthnNewDeviceStartWithHttpInfo(appId: kotlin.String, user: ApiactivateMagicLinkRequest) : ApiResponse<ApimagicLinkNewDeviceWebAuthnStartResponse?> = withContext(Dispatchers.IO) {
        val localVariableConfig = activateMagicLinkWebauthnNewDeviceStartRequestConfig(appId = appId, user = user)

        return@withContext request<ApiactivateMagicLinkRequest, ApimagicLinkNewDeviceWebAuthnStartResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation activateMagicLinkWebauthnNewDeviceStart
     *
     * @param appId App ID
     * @param user User Data
     * @return RequestConfig
     */
    fun activateMagicLinkWebauthnNewDeviceStartRequestConfig(appId: kotlin.String, user: ApiactivateMagicLinkRequest) : RequestConfig<ApiactivateMagicLinkRequest> {
        val localVariableBody = user
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/apps/{app_id}/magic-link/webauthn/new/start/".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Magic Link Status
     * Check if a magic link has been activated yet or not. Once the magic link has been activated, this endpoint will return an authentication token for the user. This endpoint can be used to initiate a login in one device and then poll and wait for the login to complete on another device.
     * @param appId App ID
     * @param user Magic Link ID
     * @return ApiAuthResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun magicLinkStatus(appId: kotlin.String, user: ApigetMagicLinkStatusRequest) : ApiAuthResponse = withContext(Dispatchers.IO) {
        val localVarResponse = magicLinkStatusWithHttpInfo(appId = appId, user = user)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ApiAuthResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Magic Link Status
     * Check if a magic link has been activated yet or not. Once the magic link has been activated, this endpoint will return an authentication token for the user. This endpoint can be used to initiate a login in one device and then poll and wait for the login to complete on another device.
     * @param appId App ID
     * @param user Magic Link ID
     * @return ApiResponse<ApiAuthResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun magicLinkStatusWithHttpInfo(appId: kotlin.String, user: ApigetMagicLinkStatusRequest) : ApiResponse<ApiAuthResponse?> = withContext(Dispatchers.IO) {
        val localVariableConfig = magicLinkStatusRequestConfig(appId = appId, user = user)

        return@withContext request<ApigetMagicLinkStatusRequest, ApiAuthResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation magicLinkStatus
     *
     * @param appId App ID
     * @param user Magic Link ID
     * @return RequestConfig
     */
    fun magicLinkStatusRequestConfig(appId: kotlin.String, user: ApigetMagicLinkStatusRequest) : RequestConfig<ApigetMagicLinkStatusRequest> {
        val localVariableBody = user
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/apps/{app_id}/magic-link/status/".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
