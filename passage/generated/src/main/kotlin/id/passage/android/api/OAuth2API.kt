/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package id.passage.android.api

import android.util.Log
import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import id.passage.android.model.AuthErrorCode
import id.passage.android.model.AuthResponse
import id.passage.android.model.Model400Error
import id.passage.android.model.Model403Error
import id.passage.android.model.Model500Error
import id.passage.android.model.OAuth2ConnectionType

import com.squareup.moshi.Json

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import id.passage.client.infrastructure.ApiClient
import id.passage.client.infrastructure.ApiResponse
import id.passage.client.infrastructure.ClientException
import id.passage.client.infrastructure.ClientError
import id.passage.client.infrastructure.ServerException
import id.passage.client.infrastructure.ServerError
import id.passage.client.infrastructure.MultiValueMap
import id.passage.client.infrastructure.PartConfig
import id.passage.client.infrastructure.RequestConfig
import id.passage.client.infrastructure.RequestMethod
import id.passage.client.infrastructure.ResponseType
import id.passage.client.infrastructure.Success
import id.passage.client.infrastructure.toMultiValue

class OAuth2API(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://auth.passage.id/v1")
        }
    }

    /**
     * Link an existing account to an OAuth2 connection.
     * 
     * @param appId App ID
     * @param code The code given from the OAuth2 redirect
     * @param verifier The verifier the client originally sent to the OAuth2 provider
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun currentuserSocialLinkAccount(appId: kotlin.String, code: kotlin.String, verifier: kotlin.String) : Unit = withContext(Dispatchers.IO) {
        val localVarResponse = currentuserSocialLinkAccountWithHttpInfo(appId = appId, code = code, verifier = verifier)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Link an existing account to an OAuth2 connection.
     * 
     * @param appId App ID
     * @param code The code given from the OAuth2 redirect
     * @param verifier The verifier the client originally sent to the OAuth2 provider
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun currentuserSocialLinkAccountWithHttpInfo(appId: kotlin.String, code: kotlin.String, verifier: kotlin.String) : ApiResponse<Unit?> = withContext(Dispatchers.IO) {
        val localVariableConfig = currentuserSocialLinkAccountRequestConfig(appId = appId, code = code, verifier = verifier)

        return@withContext request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation currentuserSocialLinkAccount
     *
     * @param appId App ID
     * @param code The code given from the OAuth2 redirect
     * @param verifier The verifier the client originally sent to the OAuth2 provider
     * @return RequestConfig
     */
    fun currentuserSocialLinkAccountRequestConfig(appId: kotlin.String, code: kotlin.String, verifier: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("code", listOf(code.toString()))
                put("verifier", listOf(verifier.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/apps/{app_id}/currentuser/social/link_account".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Exchange OAuth2 connection data for an auth token.
     * 
     * @param appId App ID
     * @param code The code given from the OAuth2 redirect
     * @param verifier The verifier the client originally sent to the OAuth2 provider
     * @return AuthResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun exchangeSocialToken(appId: kotlin.String, code: kotlin.String, verifier: kotlin.String) : AuthResponse = withContext(Dispatchers.IO) {
        val localVarResponse = exchangeSocialTokenWithHttpInfo(appId = appId, code = code, verifier = verifier)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AuthResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Exchange OAuth2 connection data for an auth token.
     * 
     * @param appId App ID
     * @param code The code given from the OAuth2 redirect
     * @param verifier The verifier the client originally sent to the OAuth2 provider
     * @return ApiResponse<AuthResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun exchangeSocialTokenWithHttpInfo(appId: kotlin.String, code: kotlin.String, verifier: kotlin.String) : ApiResponse<AuthResponse?> = withContext(Dispatchers.IO) {
        val localVariableConfig = exchangeSocialTokenRequestConfig(appId = appId, code = code, verifier = verifier)

        return@withContext request<Unit, AuthResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exchangeSocialToken
     *
     * @param appId App ID
     * @param code The code given from the OAuth2 redirect
     * @param verifier The verifier the client originally sent to the OAuth2 provider
     * @return RequestConfig
     */
    fun exchangeSocialTokenRequestConfig(appId: kotlin.String, code: kotlin.String, verifier: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("code", listOf(code.toString()))
                put("verifier", listOf(verifier.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"
        val path = "/apps/{app_id}/social/token".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString()))
        Log.e("GENERATED", localVariableQuery.toString())
        return RequestConfig(
            method = RequestMethod.GET,
            path = path,
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Kick off OAuth2 flow
     * Kick off OAuth2 flow with connection provider request params described in https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest
     * @param appId App ID
     * @param redirectUri The URL to redirect to after the OAuth2 flow is complete.
     * @param codeChallenge Code challenge.
     * @param codeChallengeMethod Code challenge method.
     * @param connectionType connection type; google, github, apple, or passage to login with
     * @param state The state to pass through to the redirect URI. (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getAuthorize(appId: kotlin.String, redirectUri: kotlin.String, codeChallenge: kotlin.String, codeChallengeMethod: kotlin.String, connectionType: OAuth2ConnectionType, state: kotlin.String? = null) : Unit = withContext(Dispatchers.IO) {
        val localVarResponse = getAuthorizeWithHttpInfo(appId = appId, redirectUri = redirectUri, codeChallenge = codeChallenge, codeChallengeMethod = codeChallengeMethod, connectionType = connectionType, state = state)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Kick off OAuth2 flow
     * Kick off OAuth2 flow with connection provider request params described in https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest
     * @param appId App ID
     * @param redirectUri The URL to redirect to after the OAuth2 flow is complete.
     * @param codeChallenge Code challenge.
     * @param codeChallengeMethod Code challenge method.
     * @param connectionType connection type; google, github, apple, or passage to login with
     * @param state The state to pass through to the redirect URI. (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun getAuthorizeWithHttpInfo(appId: kotlin.String, redirectUri: kotlin.String, codeChallenge: kotlin.String, codeChallengeMethod: kotlin.String, connectionType: OAuth2ConnectionType, state: kotlin.String?) : ApiResponse<Unit?> = withContext(Dispatchers.IO) {
        val localVariableConfig = getAuthorizeRequestConfig(appId = appId, redirectUri = redirectUri, codeChallenge = codeChallenge, codeChallengeMethod = codeChallengeMethod, connectionType = connectionType, state = state)

        return@withContext request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAuthorize
     *
     * @param appId App ID
     * @param redirectUri The URL to redirect to after the OAuth2 flow is complete.
     * @param codeChallenge Code challenge.
     * @param codeChallengeMethod Code challenge method.
     * @param connectionType connection type; google, github, apple, or passage to login with
     * @param state The state to pass through to the redirect URI. (optional)
     * @return RequestConfig
     */
    fun getAuthorizeRequestConfig(appId: kotlin.String, redirectUri: kotlin.String, codeChallenge: kotlin.String, codeChallengeMethod: kotlin.String, connectionType: OAuth2ConnectionType, state: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("redirect_uri", listOf(redirectUri.toString()))
                if (state != null) {
                    put("state", listOf(state.toString()))
                }
                put("code_challenge", listOf(codeChallenge.toString()))
                put("code_challenge_method", listOf(codeChallengeMethod.toString()))
                put("connection_type", listOf(connectionType.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/apps/{app_id}/social/authorize".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Handle OAuth2 callback
     * 
     * @param appId App ID
     * @param code The authorization code returned by the OAuth2 provider.
     * @param state The state returned by the OAuth2 provider. (optional)
     * @param error The error returned by the OAuth2 provider. (optional)
     * @param errorDescription The error description returned by the OAuth2 provider. (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun oauth2Callback(appId: kotlin.String, code: kotlin.String, state: kotlin.String? = null, error: AuthErrorCode? = null, errorDescription: kotlin.String? = null) : Unit = withContext(Dispatchers.IO) {
        val localVarResponse = oauth2CallbackWithHttpInfo(appId = appId, code = code, state = state, error = error, errorDescription = errorDescription)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Handle OAuth2 callback
     * 
     * @param appId App ID
     * @param code The authorization code returned by the OAuth2 provider.
     * @param state The state returned by the OAuth2 provider. (optional)
     * @param error The error returned by the OAuth2 provider. (optional)
     * @param errorDescription The error description returned by the OAuth2 provider. (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun oauth2CallbackWithHttpInfo(appId: kotlin.String, code: kotlin.String, state: kotlin.String?, error: AuthErrorCode?, errorDescription: kotlin.String?) : ApiResponse<Unit?> = withContext(Dispatchers.IO) {
        val localVariableConfig = oauth2CallbackRequestConfig(appId = appId, code = code, state = state, error = error, errorDescription = errorDescription)

        return@withContext request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation oauth2Callback
     *
     * @param appId App ID
     * @param code The authorization code returned by the OAuth2 provider.
     * @param state The state returned by the OAuth2 provider. (optional)
     * @param error The error returned by the OAuth2 provider. (optional)
     * @param errorDescription The error description returned by the OAuth2 provider. (optional)
     * @return RequestConfig
     */
    fun oauth2CallbackRequestConfig(appId: kotlin.String, code: kotlin.String, state: kotlin.String?, error: AuthErrorCode?, errorDescription: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("code", listOf(code.toString()))
                if (state != null) {
                    put("state", listOf(state.toString()))
                }
                if (error != null) {
                    put("error", listOf(error.toString()))
                }
                if (errorDescription != null) {
                    put("error_description", listOf(errorDescription.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/apps/{app_id}/social/oauth2_callback".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
