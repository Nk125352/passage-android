/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package id.passage.android.api

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import id.passage.android.model.APIError
import id.passage.android.model.ApiregisterMagicLinkRequest
import id.passage.android.model.ApiregisterMagicLinkResponse
import id.passage.android.model.AuthResponse1
import id.passage.android.model.HttpErrorsHTTPError
import id.passage.android.model.Model400Error
import id.passage.android.model.Model401Error
import id.passage.android.model.Model403Error
import id.passage.android.model.Model404Error
import id.passage.android.model.Model500Error
import id.passage.android.model.OneTimePasscodeResponse
import id.passage.android.model.RegisterOneTimePasscodeRequest
import id.passage.android.model.RegisterWebAuthnFinishRequest
import id.passage.android.model.RegisterWebAuthnStartRequest
import id.passage.android.model.RegisterWebAuthnStartResponse

import com.squareup.moshi.Json

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import id.passage.client.infrastructure.ApiClient
import id.passage.client.infrastructure.ApiResponse
import id.passage.client.infrastructure.ClientException
import id.passage.client.infrastructure.ClientError
import id.passage.client.infrastructure.ServerException
import id.passage.client.infrastructure.ServerError
import id.passage.client.infrastructure.MultiValueMap
import id.passage.client.infrastructure.PartConfig
import id.passage.client.infrastructure.RequestConfig
import id.passage.client.infrastructure.RequestMethod
import id.passage.client.infrastructure.ResponseType
import id.passage.client.infrastructure.Success
import id.passage.client.infrastructure.toMultiValue

class RegisterAPI(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://virtserver.swaggerhub.com/passage_swagger/auth-gw/v1")
        }
    }

    /**
     * Register with Magic Link
     * Create a user and send an registration email or SMS to the user. The user will receive an email or text with a link to complete their registration.
     * @param appId App ID
     * @param user User Data
     * @return ApiregisterMagicLinkResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun registerMagicLink(appId: kotlin.String, user: ApiregisterMagicLinkRequest) : ApiregisterMagicLinkResponse = withContext(Dispatchers.IO) {
        val localVarResponse = registerMagicLinkWithHttpInfo(appId = appId, user = user)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ApiregisterMagicLinkResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Register with Magic Link
     * Create a user and send an registration email or SMS to the user. The user will receive an email or text with a link to complete their registration.
     * @param appId App ID
     * @param user User Data
     * @return ApiResponse<ApiregisterMagicLinkResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun registerMagicLinkWithHttpInfo(appId: kotlin.String, user: ApiregisterMagicLinkRequest) : ApiResponse<ApiregisterMagicLinkResponse?> = withContext(Dispatchers.IO) {
        val localVariableConfig = registerMagicLinkRequestConfig(appId = appId, user = user)

        return@withContext request<ApiregisterMagicLinkRequest, ApiregisterMagicLinkResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation registerMagicLink
     *
     * @param appId App ID
     * @param user User Data
     * @return RequestConfig
     */
    fun registerMagicLinkRequestConfig(appId: kotlin.String, user: ApiregisterMagicLinkRequest) : RequestConfig<ApiregisterMagicLinkRequest> {
        val localVariableBody = user
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/apps/{app_id}/register/magic-link/".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Register with OTP
     * Create a user and send a registration email or SMS to the user. The user will receive an email or text with a one-time passcode to complete their registration.
     * @param appId App ID
     * @param registerOneTimePasscodeRequest User Data
     * @return OneTimePasscodeResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun registerOneTimePasscode(appId: kotlin.String, registerOneTimePasscodeRequest: RegisterOneTimePasscodeRequest) : OneTimePasscodeResponse = withContext(Dispatchers.IO) {
        val localVarResponse = registerOneTimePasscodeWithHttpInfo(appId = appId, registerOneTimePasscodeRequest = registerOneTimePasscodeRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OneTimePasscodeResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Register with OTP
     * Create a user and send a registration email or SMS to the user. The user will receive an email or text with a one-time passcode to complete their registration.
     * @param appId App ID
     * @param registerOneTimePasscodeRequest User Data
     * @return ApiResponse<OneTimePasscodeResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun registerOneTimePasscodeWithHttpInfo(appId: kotlin.String, registerOneTimePasscodeRequest: RegisterOneTimePasscodeRequest) : ApiResponse<OneTimePasscodeResponse?> = withContext(Dispatchers.IO) {
        val localVariableConfig = registerOneTimePasscodeRequestConfig(appId = appId, registerOneTimePasscodeRequest = registerOneTimePasscodeRequest)

        return@withContext request<RegisterOneTimePasscodeRequest, OneTimePasscodeResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation registerOneTimePasscode
     *
     * @param appId App ID
     * @param registerOneTimePasscodeRequest User Data
     * @return RequestConfig
     */
    fun registerOneTimePasscodeRequestConfig(appId: kotlin.String, registerOneTimePasscodeRequest: RegisterOneTimePasscodeRequest) : RequestConfig<RegisterOneTimePasscodeRequest> {
        val localVariableBody = registerOneTimePasscodeRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/apps/{app_id}/register/otp".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Finish WebAuthn Registration
     * Complete a WebAuthn registration and authenticate the user. This endpoint accepts and verifies the response from &#x60;navigator.credential.create()&#x60; and returns an authentication token for the user.
     * @param appId App ID
     * @param registerWebAuthnFinishRequest WebAuthn Response Data
     * @return AuthResponse1
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun registerWebauthnFinish(appId: kotlin.String, registerWebAuthnFinishRequest: RegisterWebAuthnFinishRequest) : AuthResponse1 = withContext(Dispatchers.IO) {
        val localVarResponse = registerWebauthnFinishWithHttpInfo(appId = appId, registerWebAuthnFinishRequest = registerWebAuthnFinishRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AuthResponse1
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Finish WebAuthn Registration
     * Complete a WebAuthn registration and authenticate the user. This endpoint accepts and verifies the response from &#x60;navigator.credential.create()&#x60; and returns an authentication token for the user.
     * @param appId App ID
     * @param registerWebAuthnFinishRequest WebAuthn Response Data
     * @return ApiResponse<AuthResponse1?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun registerWebauthnFinishWithHttpInfo(appId: kotlin.String, registerWebAuthnFinishRequest: RegisterWebAuthnFinishRequest) : ApiResponse<AuthResponse1?> = withContext(Dispatchers.IO) {
        val localVariableConfig = registerWebauthnFinishRequestConfig(appId = appId, registerWebAuthnFinishRequest = registerWebAuthnFinishRequest)

        return@withContext request<RegisterWebAuthnFinishRequest, AuthResponse1>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation registerWebauthnFinish
     *
     * @param appId App ID
     * @param registerWebAuthnFinishRequest WebAuthn Response Data
     * @return RequestConfig
     */
    fun registerWebauthnFinishRequestConfig(appId: kotlin.String, registerWebAuthnFinishRequest: RegisterWebAuthnFinishRequest) : RequestConfig<RegisterWebAuthnFinishRequest> {
        val localVariableBody = registerWebAuthnFinishRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/apps/{app_id}/register/webauthn/finish".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Start WebAuthn Register
     * Initiate a WebAuthn registration and create the user. This endpoint creates a WebAuthn credential creation challenge that is used to perform the registration ceremony from the browser.
     * @param appId App ID
     * @param registerWebAuthnStartRequest User Data
     * @return RegisterWebAuthnStartResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun registerWebauthnStart(appId: kotlin.String, registerWebAuthnStartRequest: RegisterWebAuthnStartRequest) : RegisterWebAuthnStartResponse = withContext(Dispatchers.IO) {
        val localVarResponse = registerWebauthnStartWithHttpInfo(appId = appId, registerWebAuthnStartRequest = registerWebAuthnStartRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RegisterWebAuthnStartResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Start WebAuthn Register
     * Initiate a WebAuthn registration and create the user. This endpoint creates a WebAuthn credential creation challenge that is used to perform the registration ceremony from the browser.
     * @param appId App ID
     * @param registerWebAuthnStartRequest User Data
     * @return ApiResponse<RegisterWebAuthnStartResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun registerWebauthnStartWithHttpInfo(appId: kotlin.String, registerWebAuthnStartRequest: RegisterWebAuthnStartRequest) : ApiResponse<RegisterWebAuthnStartResponse?> = withContext(Dispatchers.IO) {
        val localVariableConfig = registerWebauthnStartRequestConfig(appId = appId, registerWebAuthnStartRequest = registerWebAuthnStartRequest)

        return@withContext request<RegisterWebAuthnStartRequest, RegisterWebAuthnStartResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation registerWebauthnStart
     *
     * @param appId App ID
     * @param registerWebAuthnStartRequest User Data
     * @return RequestConfig
     */
    fun registerWebauthnStartRequestConfig(appId: kotlin.String, registerWebAuthnStartRequest: RegisterWebAuthnStartRequest) : RequestConfig<RegisterWebAuthnStartRequest> {
        val localVariableBody = registerWebAuthnStartRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/apps/{app_id}/register/webauthn/start".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
