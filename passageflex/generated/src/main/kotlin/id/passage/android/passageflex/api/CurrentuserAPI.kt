/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package id.passage.android.passageflex.api

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import id.passage.android.passageflex.model.AddDeviceFinishRequest
import id.passage.android.passageflex.model.AddDeviceStartResponse
import id.passage.android.passageflex.model.CurrentUserDevice
import id.passage.android.passageflex.model.CurrentUserDevices
import id.passage.android.passageflex.model.CurrentUserDevicesStartRequest
import id.passage.android.passageflex.model.CurrentUserResponse
import id.passage.android.passageflex.model.MagicLinkResponse
import id.passage.android.passageflex.model.Model400Error
import id.passage.android.passageflex.model.Model401Error
import id.passage.android.passageflex.model.Model403Error
import id.passage.android.passageflex.model.Model404Error
import id.passage.android.passageflex.model.Model500Error
import id.passage.android.passageflex.model.SocialConnectionsResponse
import id.passage.android.passageflex.model.UpdateDeviceRequest
import id.passage.android.passageflex.model.UpdateMetadataRequest
import id.passage.android.passageflex.model.UpdateUserEmailRequest
import id.passage.android.passageflex.model.UpdateUserPhoneRequest
import id.passage.android.passageflex.model.UserMetadataResponse

import com.squareup.moshi.Json

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import id.passage.passageflex.client.infrastructure.ApiClient
import id.passage.passageflex.client.infrastructure.ApiResponse
import id.passage.passageflex.client.infrastructure.ClientException
import id.passage.passageflex.client.infrastructure.ClientError
import id.passage.passageflex.client.infrastructure.ServerException
import id.passage.passageflex.client.infrastructure.ServerError
import id.passage.passageflex.client.infrastructure.MultiValueMap
import id.passage.passageflex.client.infrastructure.PartConfig
import id.passage.passageflex.client.infrastructure.RequestConfig
import id.passage.passageflex.client.infrastructure.RequestMethod
import id.passage.passageflex.client.infrastructure.ResponseType
import id.passage.passageflex.client.infrastructure.Success
import id.passage.passageflex.client.infrastructure.toMultiValue

class CurrentuserAPI(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://auth.passage.id/v1")
        }
    }

    /**
     * Revoke Device
     * Revoke a device by ID for the current user. User must be authenticated via a bearer token.
     * @param appId App ID
     * @param deviceId Device ID
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun deleteCurrentuserDevice(appId: kotlin.String, deviceId: kotlin.String) : Unit = withContext(Dispatchers.IO) {
        val localVarResponse = deleteCurrentuserDeviceWithHttpInfo(appId = appId, deviceId = deviceId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Revoke Device
     * Revoke a device by ID for the current user. User must be authenticated via a bearer token.
     * @param appId App ID
     * @param deviceId Device ID
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun deleteCurrentuserDeviceWithHttpInfo(appId: kotlin.String, deviceId: kotlin.String) : ApiResponse<Unit?> = withContext(Dispatchers.IO) {
        val localVariableConfig = deleteCurrentuserDeviceRequestConfig(appId = appId, deviceId = deviceId)

        return@withContext request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteCurrentuserDevice
     *
     * @param appId App ID
     * @param deviceId Device ID
     * @return RequestConfig
     */
    fun deleteCurrentuserDeviceRequestConfig(appId: kotlin.String, deviceId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/apps/{app_id}/currentuser/devices/{device_id}".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())).replace("{"+"device_id"+"}", encodeURIComponent(deviceId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter socialConnectionType
     */
     enum class SocialConnectionType_deleteCurrentuserSocialConnection(val value: kotlin.String) {
         @Json(name = "apple") apple("apple"),
         @Json(name = "github") github("github"),
         @Json(name = "google") google("google")
     }

    /**
     * Delete Social Connection
     * Deletes a social connection for the current user. User must be authenticated via a bearer token.
     * @param appId App ID
     * @param socialConnectionType The type of social connection
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun deleteCurrentuserSocialConnection(appId: kotlin.String, socialConnectionType: SocialConnectionType_deleteCurrentuserSocialConnection) : Unit = withContext(Dispatchers.IO) {
        val localVarResponse = deleteCurrentuserSocialConnectionWithHttpInfo(appId = appId, socialConnectionType = socialConnectionType)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete Social Connection
     * Deletes a social connection for the current user. User must be authenticated via a bearer token.
     * @param appId App ID
     * @param socialConnectionType The type of social connection
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun deleteCurrentuserSocialConnectionWithHttpInfo(appId: kotlin.String, socialConnectionType: SocialConnectionType_deleteCurrentuserSocialConnection) : ApiResponse<Unit?> = withContext(Dispatchers.IO) {
        val localVariableConfig = deleteCurrentuserSocialConnectionRequestConfig(appId = appId, socialConnectionType = socialConnectionType)

        return@withContext request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteCurrentuserSocialConnection
     *
     * @param appId App ID
     * @param socialConnectionType The type of social connection
     * @return RequestConfig
     */
    fun deleteCurrentuserSocialConnectionRequestConfig(appId: kotlin.String, socialConnectionType: SocialConnectionType_deleteCurrentuserSocialConnection) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/apps/{app_id}/currentuser/social-connections/{social_connection_type}".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())).replace("{"+"social_connection_type"+"}", encodeURIComponent(socialConnectionType.value.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get Current User
     * Get information about a user that is currently authenticated via bearer token.
     * @param appId App ID
     * @return CurrentUserResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getCurrentuser(appId: kotlin.String) : CurrentUserResponse = withContext(Dispatchers.IO) {
        val localVarResponse = getCurrentuserWithHttpInfo(appId = appId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CurrentUserResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Current User
     * Get information about a user that is currently authenticated via bearer token.
     * @param appId App ID
     * @return ApiResponse<CurrentUserResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun getCurrentuserWithHttpInfo(appId: kotlin.String) : ApiResponse<CurrentUserResponse?> = withContext(Dispatchers.IO) {
        val localVariableConfig = getCurrentuserRequestConfig(appId = appId)

        return@withContext request<Unit, CurrentUserResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getCurrentuser
     *
     * @param appId App ID
     * @return RequestConfig
     */
    fun getCurrentuserRequestConfig(appId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/apps/{app_id}/currentuser".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * List Devices
     * List all WebAuthn devices for the authenticated user. User must be authenticated via bearer token.
     * @param appId App ID
     * @return CurrentUserDevices
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getCurrentuserDevices(appId: kotlin.String) : CurrentUserDevices = withContext(Dispatchers.IO) {
        val localVarResponse = getCurrentuserDevicesWithHttpInfo(appId = appId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CurrentUserDevices
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List Devices
     * List all WebAuthn devices for the authenticated user. User must be authenticated via bearer token.
     * @param appId App ID
     * @return ApiResponse<CurrentUserDevices?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun getCurrentuserDevicesWithHttpInfo(appId: kotlin.String) : ApiResponse<CurrentUserDevices?> = withContext(Dispatchers.IO) {
        val localVariableConfig = getCurrentuserDevicesRequestConfig(appId = appId)

        return@withContext request<Unit, CurrentUserDevices>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getCurrentuserDevices
     *
     * @param appId App ID
     * @return RequestConfig
     */
    fun getCurrentuserDevicesRequestConfig(appId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/apps/{app_id}/currentuser/devices".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get user&#39;s metadata
     * Get the user-metadata for the current user.
     * @param appId App ID
     * @return UserMetadataResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getCurrentuserMetadata(appId: kotlin.String) : UserMetadataResponse = withContext(Dispatchers.IO) {
        val localVarResponse = getCurrentuserMetadataWithHttpInfo(appId = appId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserMetadataResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get user&#39;s metadata
     * Get the user-metadata for the current user.
     * @param appId App ID
     * @return ApiResponse<UserMetadataResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun getCurrentuserMetadataWithHttpInfo(appId: kotlin.String) : ApiResponse<UserMetadataResponse?> = withContext(Dispatchers.IO) {
        val localVariableConfig = getCurrentuserMetadataRequestConfig(appId = appId)

        return@withContext request<Unit, UserMetadataResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getCurrentuserMetadata
     *
     * @param appId App ID
     * @return RequestConfig
     */
    fun getCurrentuserMetadataRequestConfig(appId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/apps/{app_id}/currentuser/user-metadata".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get Social Connections
     * Gets social connections for the current user. User must be authenticated via a bearer token.
     * @param appId App ID
     * @return SocialConnectionsResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getCurrentuserSocialConnections(appId: kotlin.String) : SocialConnectionsResponse = withContext(Dispatchers.IO) {
        val localVarResponse = getCurrentuserSocialConnectionsWithHttpInfo(appId = appId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SocialConnectionsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Social Connections
     * Gets social connections for the current user. User must be authenticated via a bearer token.
     * @param appId App ID
     * @return ApiResponse<SocialConnectionsResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun getCurrentuserSocialConnectionsWithHttpInfo(appId: kotlin.String) : ApiResponse<SocialConnectionsResponse?> = withContext(Dispatchers.IO) {
        val localVariableConfig = getCurrentuserSocialConnectionsRequestConfig(appId = appId)

        return@withContext request<Unit, SocialConnectionsResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getCurrentuserSocialConnections
     *
     * @param appId App ID
     * @return RequestConfig
     */
    fun getCurrentuserSocialConnectionsRequestConfig(appId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/apps/{app_id}/currentuser/social-connections".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Finish WebAuthn Add Device
     * Complete a WebAuthn add device operation for the current user. This endpoint accepts and verifies the response from &#x60;navigator.credential.create()&#x60; and returns the created device for the user. User must be authenticated via a bearer token.
     * @param appId App ID
     * @param addDeviceFinishRequest WebAuthn Response Data
     * @return CurrentUserDevice
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun postCurrentuserAddDeviceFinish(appId: kotlin.String, addDeviceFinishRequest: AddDeviceFinishRequest) : CurrentUserDevice = withContext(Dispatchers.IO) {
        val localVarResponse = postCurrentuserAddDeviceFinishWithHttpInfo(appId = appId, addDeviceFinishRequest = addDeviceFinishRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CurrentUserDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Finish WebAuthn Add Device
     * Complete a WebAuthn add device operation for the current user. This endpoint accepts and verifies the response from &#x60;navigator.credential.create()&#x60; and returns the created device for the user. User must be authenticated via a bearer token.
     * @param appId App ID
     * @param addDeviceFinishRequest WebAuthn Response Data
     * @return ApiResponse<CurrentUserDevice?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun postCurrentuserAddDeviceFinishWithHttpInfo(appId: kotlin.String, addDeviceFinishRequest: AddDeviceFinishRequest) : ApiResponse<CurrentUserDevice?> = withContext(Dispatchers.IO) {
        val localVariableConfig = postCurrentuserAddDeviceFinishRequestConfig(appId = appId, addDeviceFinishRequest = addDeviceFinishRequest)

        return@withContext request<AddDeviceFinishRequest, CurrentUserDevice>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postCurrentuserAddDeviceFinish
     *
     * @param appId App ID
     * @param addDeviceFinishRequest WebAuthn Response Data
     * @return RequestConfig
     */
    fun postCurrentuserAddDeviceFinishRequestConfig(appId: kotlin.String, addDeviceFinishRequest: AddDeviceFinishRequest) : RequestConfig<AddDeviceFinishRequest> {
        val localVariableBody = addDeviceFinishRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/apps/{app_id}/currentuser/devices/finish".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Start WebAuthn Add Device
     * Initiate a WebAuthn add device operation for the current user. This endpoint creates a WebAuthn credential creation challenge that is used to perform the registration ceremony from the browser. User must be authenticated via a bearer token.
     * @param appId App ID
     * @param currentUserDevicesStartRequest WebAuthn Start Response Data (optional)
     * @return AddDeviceStartResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun postCurrentuserAddDeviceStart(appId: kotlin.String, currentUserDevicesStartRequest: CurrentUserDevicesStartRequest? = null) : AddDeviceStartResponse = withContext(Dispatchers.IO) {
        val localVarResponse = postCurrentuserAddDeviceStartWithHttpInfo(appId = appId, currentUserDevicesStartRequest = currentUserDevicesStartRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AddDeviceStartResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Start WebAuthn Add Device
     * Initiate a WebAuthn add device operation for the current user. This endpoint creates a WebAuthn credential creation challenge that is used to perform the registration ceremony from the browser. User must be authenticated via a bearer token.
     * @param appId App ID
     * @param currentUserDevicesStartRequest WebAuthn Start Response Data (optional)
     * @return ApiResponse<AddDeviceStartResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun postCurrentuserAddDeviceStartWithHttpInfo(appId: kotlin.String, currentUserDevicesStartRequest: CurrentUserDevicesStartRequest?) : ApiResponse<AddDeviceStartResponse?> = withContext(Dispatchers.IO) {
        val localVariableConfig = postCurrentuserAddDeviceStartRequestConfig(appId = appId, currentUserDevicesStartRequest = currentUserDevicesStartRequest)

        return@withContext request<CurrentUserDevicesStartRequest, AddDeviceStartResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postCurrentuserAddDeviceStart
     *
     * @param appId App ID
     * @param currentUserDevicesStartRequest WebAuthn Start Response Data (optional)
     * @return RequestConfig
     */
    fun postCurrentuserAddDeviceStartRequestConfig(appId: kotlin.String, currentUserDevicesStartRequest: CurrentUserDevicesStartRequest?) : RequestConfig<CurrentUserDevicesStartRequest> {
        val localVariableBody = currentUserDevicesStartRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/apps/{app_id}/currentuser/devices/start".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Update Device
     * Update a device by ID for the current user. Currently the only field that can be updated is the friendly name. User must be authenticated via a bearer token.
     * @param appId App ID
     * @param deviceId Device ID
     * @param updateDeviceRequest Friendly Name
     * @return CurrentUserDevice
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun updateCurrentuserDevice(appId: kotlin.String, deviceId: kotlin.String, updateDeviceRequest: UpdateDeviceRequest) : CurrentUserDevice = withContext(Dispatchers.IO) {
        val localVarResponse = updateCurrentuserDeviceWithHttpInfo(appId = appId, deviceId = deviceId, updateDeviceRequest = updateDeviceRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CurrentUserDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update Device
     * Update a device by ID for the current user. Currently the only field that can be updated is the friendly name. User must be authenticated via a bearer token.
     * @param appId App ID
     * @param deviceId Device ID
     * @param updateDeviceRequest Friendly Name
     * @return ApiResponse<CurrentUserDevice?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun updateCurrentuserDeviceWithHttpInfo(appId: kotlin.String, deviceId: kotlin.String, updateDeviceRequest: UpdateDeviceRequest) : ApiResponse<CurrentUserDevice?> = withContext(Dispatchers.IO) {
        val localVariableConfig = updateCurrentuserDeviceRequestConfig(appId = appId, deviceId = deviceId, updateDeviceRequest = updateDeviceRequest)

        return@withContext request<UpdateDeviceRequest, CurrentUserDevice>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateCurrentuserDevice
     *
     * @param appId App ID
     * @param deviceId Device ID
     * @param updateDeviceRequest Friendly Name
     * @return RequestConfig
     */
    fun updateCurrentuserDeviceRequestConfig(appId: kotlin.String, deviceId: kotlin.String, updateDeviceRequest: UpdateDeviceRequest) : RequestConfig<UpdateDeviceRequest> {
        val localVariableBody = updateDeviceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/apps/{app_id}/currentuser/devices/{device_id}".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())).replace("{"+"device_id"+"}", encodeURIComponent(deviceId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Update user&#39;s metadata
     * Update the metadata for the current user. Only valid metadata fields are accepted. Invalid metadata fields that are present will abort the update. User must be authenticated via a bearer token.
     * @param appId App ID
     * @param updateMetadataRequest User Metadata
     * @return CurrentUserResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun updateCurrentuserMetadata(appId: kotlin.String, updateMetadataRequest: UpdateMetadataRequest) : CurrentUserResponse = withContext(Dispatchers.IO) {
        val localVarResponse = updateCurrentuserMetadataWithHttpInfo(appId = appId, updateMetadataRequest = updateMetadataRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CurrentUserResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update user&#39;s metadata
     * Update the metadata for the current user. Only valid metadata fields are accepted. Invalid metadata fields that are present will abort the update. User must be authenticated via a bearer token.
     * @param appId App ID
     * @param updateMetadataRequest User Metadata
     * @return ApiResponse<CurrentUserResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun updateCurrentuserMetadataWithHttpInfo(appId: kotlin.String, updateMetadataRequest: UpdateMetadataRequest) : ApiResponse<CurrentUserResponse?> = withContext(Dispatchers.IO) {
        val localVariableConfig = updateCurrentuserMetadataRequestConfig(appId = appId, updateMetadataRequest = updateMetadataRequest)

        return@withContext request<UpdateMetadataRequest, CurrentUserResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateCurrentuserMetadata
     *
     * @param appId App ID
     * @param updateMetadataRequest User Metadata
     * @return RequestConfig
     */
    fun updateCurrentuserMetadataRequestConfig(appId: kotlin.String, updateMetadataRequest: UpdateMetadataRequest) : RequestConfig<UpdateMetadataRequest> {
        val localVariableBody = updateMetadataRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/apps/{app_id}/currentuser/user-metadata".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Change Email
     * Initiate an email change for the authenticated user. An email change requires verification, so an email will be sent to the user which they must verify before the email change takes effect.
     * @param appId App ID
     * @param updateUserEmailRequest email
     * @return MagicLinkResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun updateEmailCurrentuser(appId: kotlin.String, updateUserEmailRequest: UpdateUserEmailRequest) : MagicLinkResponse = withContext(Dispatchers.IO) {
        val localVarResponse = updateEmailCurrentuserWithHttpInfo(appId = appId, updateUserEmailRequest = updateUserEmailRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MagicLinkResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Change Email
     * Initiate an email change for the authenticated user. An email change requires verification, so an email will be sent to the user which they must verify before the email change takes effect.
     * @param appId App ID
     * @param updateUserEmailRequest email
     * @return ApiResponse<MagicLinkResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun updateEmailCurrentuserWithHttpInfo(appId: kotlin.String, updateUserEmailRequest: UpdateUserEmailRequest) : ApiResponse<MagicLinkResponse?> = withContext(Dispatchers.IO) {
        val localVariableConfig = updateEmailCurrentuserRequestConfig(appId = appId, updateUserEmailRequest = updateUserEmailRequest)

        return@withContext request<UpdateUserEmailRequest, MagicLinkResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateEmailCurrentuser
     *
     * @param appId App ID
     * @param updateUserEmailRequest email
     * @return RequestConfig
     */
    fun updateEmailCurrentuserRequestConfig(appId: kotlin.String, updateUserEmailRequest: UpdateUserEmailRequest) : RequestConfig<UpdateUserEmailRequest> {
        val localVariableBody = updateUserEmailRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/apps/{app_id}/currentuser/email".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Change Phone
     * Initiate a phone number change for the authenticated user. An phone number change requires verification, so an SMS with a link will be sent to the user which they must verify before the phone number change takes effect.
     * @param appId App ID
     * @param updateUserPhoneRequest phone
     * @return MagicLinkResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun updatePhoneCurrentuser(appId: kotlin.String, updateUserPhoneRequest: UpdateUserPhoneRequest) : MagicLinkResponse = withContext(Dispatchers.IO) {
        val localVarResponse = updatePhoneCurrentuserWithHttpInfo(appId = appId, updateUserPhoneRequest = updateUserPhoneRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MagicLinkResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Change Phone
     * Initiate a phone number change for the authenticated user. An phone number change requires verification, so an SMS with a link will be sent to the user which they must verify before the phone number change takes effect.
     * @param appId App ID
     * @param updateUserPhoneRequest phone
     * @return ApiResponse<MagicLinkResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun updatePhoneCurrentuserWithHttpInfo(appId: kotlin.String, updateUserPhoneRequest: UpdateUserPhoneRequest) : ApiResponse<MagicLinkResponse?> = withContext(Dispatchers.IO) {
        val localVariableConfig = updatePhoneCurrentuserRequestConfig(appId = appId, updateUserPhoneRequest = updateUserPhoneRequest)

        return@withContext request<UpdateUserPhoneRequest, MagicLinkResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updatePhoneCurrentuser
     *
     * @param appId App ID
     * @param updateUserPhoneRequest phone
     * @return RequestConfig
     */
    fun updatePhoneCurrentuserRequestConfig(appId: kotlin.String, updateUserPhoneRequest: UpdateUserPhoneRequest) : RequestConfig<UpdateUserPhoneRequest> {
        val localVariableBody = updateUserPhoneRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/apps/{app_id}/currentuser/phone".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
